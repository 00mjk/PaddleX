# Data Annotation Tools

PaddleX supports four common vision tasks: image classification, object detection, instance segmentation, and semantic segmentation. For each type of vision task, specific data formats are supported. PaddleX currently supports ImageNet format for image classification, PascalVOC format for object detection, MSCOCO format for instance segmentation (MSCOCO can also be used for object detection), and semantic segmentation data formats.

## Common annotation tools

No annotation tool is needed for image classification, users only need to record the category labels of each image in a txt file. For object detection, instance segmentation and semantic segmentation, PaddleX adapts to the mainstream annotation tools. You can select the annotation tool for data labeling as required.

| Annotation Tools | Image Classification | Object Detection | Instance Segmentation | Semantic Segmentation | installation |
| :---------  | :------- | :------ | :------  | :------- | :----------------------------------------------- |
| Labelme | -- | √ | √ | √ | pip install labelme (local data labeling) |
| Wizard labeling | √ | √* | √ | √ | [Download from official website (local data tagging)](http://www.jinglingbiaozhu.com/) |
| EasyData | √ | √ | √ | √ | [Web page annotation (need to upload data for annotation)](https://ai.baidu.com/easydata/) |

After the data annotation, follow the procedure below to convert the annotation data to the data organization format that can be trained by PaddleX model.

***Note: The object detection data of the wizard annotation can be exported to PascalVOC format in the tool. Therefore, the paddlex does not provide the conversion from wizard annotation data to PascalVOC format.**


## Annotation data format conversion

At present, the annotation files generated by all annotation tools are json format files with the same name as the original image. For example, after the annotation is completed for `1.jpg , the `1.json` file is generated in the directory where the annotation file is saved. To perform conversion, follow the steps below:`

1. Put all the original image files in the same directory, such as `pics` directory.
2. Put all files labeled as json in the same directory, for example, `annotations` directory.
3. Run the following command for conversion:

```
paddlex --data_conversion --source labelme --to PascalVOC --pics . /pics --annotations . /annotations --save_dir . /converted_dataset_dir
```

| Parameters | Description |
| ---- | ---- |
| --source | Indicates the source of data labeling. It supports `labelme`, `jingling` and `easydata` (corresponding to LabelMe, wizard labeling assistant and EasyData respectively). |
| --to | Indicates the format that the data needs to be converted to. It supports `ImageNet` (image classification), `PascalVOC` (object detection), `MSCOCO` (instance segmentation, also for object detection), and `SEG` (semantic segmentation). |
| --pics | Specify the path to the directory where the original image is located. |
| --annotations | Specify the path of the annotation file. |

**Note**:
1. Target detection data for sprite markup can be exported to PascalVOC format within the tool, so paddlex does not provide conversion of sprite markup data to PascalVOC format.
2. When converting a LabelMe dataset to a COCO dataset, the LabelMe image file name and the json file name need to correspond to each other in order to convert correctly.

## Annotation for pictures shot by mobile phone

When sample images collected are from the mobile phone camera, it should be noted that a problem may occur in the labeling and training because the mobile phone camera information comes with horizontal and vertical orientation information. Make sure to process the pictures according to the orientation. To solve the problem, use the following function:
```
from PIL import Image, ExifTags def rotate(im):try:for orientation in ExifTags. TAGS.keys():if ExifTags. TAGS[orientation] == 'Orientation':break exif = dict(im. _getexif().items()) if exif[orientation] == 3:im = im.rotate(180, expand=True) if exif[orientation] == 6:im = im.rotate(270, expand=True) if exif[orientation] == 8:im = im.rotate(90, expand=True) except:pass img_file = '1.jpeg' im = Image.open(img_file) rotate(im) im.save('new_1.jpeg')
```
